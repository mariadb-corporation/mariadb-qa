#!/bin/bash
# Also see ~/mariadb-qa/memory_leaks_howto.txt for related throubleshooting info, otherwise unrelated to the monitoring script below

# Set oom_score_adj with sudo to avoid this process being terminated by the OS OOM killer watchdog
MYPID=$$
sudo bash -c "echo -1000 > /proc/$MYPID/oom_score_adj" || {
    echo "Failed to set oom_score_adj with sudo"
    exit 1
}
# cat /proc/$MYPID/oom_score_adj # Debug (checked)

# User variables
DS_RUNONCE_EVERY=23  # Run ${HOME}/ds once every x loops, if present (run ~/mariadb-qa/linkit to install it if not). Set to 0 to disable ds being called
KILL_PERCENT=7       # For example: 4: All processes using >=4% of memory will be killed

# Filter this list of processes from termination
# Call the process filter helper script to set the FILTER var
SCRIPT_PWD=$(dirname $(readlink -f "${0}"))
if [ -r "${SCRIPT_PWD}/mariadb-qa/process_filter.source" ]; then
  source "${SCRIPT_PWD}/mariadb-qa/process_filter.source"
elif [ -r "${SCRIPT_PWD}/process_filter.source" ]; then
  source "${SCRIPT_PWD}/process_filter.source"
elif [ -r "${HOME}/mariadb-qa/process_filter.source" ]; then
  source "${HOME}/mariadb-qa/process_filter.source"
else
  echo "Assert: process_filter.source not found/readable by this script ($0)"
  exit 1
fi

if [ "${STY}" == "" ]; then
  THIS_SCRIPT="$(readlink -f $0)"  # Resolves symlinks, result is the actual script including directory
  SCREEN_NAME='memory'
  echo "Not a screen, restarting myself inside a screen"
  screen -admS "${SCREEN_NAME}" bash -c "while true; do ${THIS_SCRIPT} ${*}; echo '***** MEMORY WATCHDOG SELF-RESTART *****'; done; bash"
  sleep 1
  screen -d -r "${SCREEN_NAME}"
  return 2> /dev/null; exit 0
fi

clear
DS_RUNONCE_LOOP=0
while :; do
  if [ "${DS_RUNONCE_EVERY}" != "0" -a ! -z "${DS_RUNONCE_EVERY}" ]; then
    DS_RUNONCE_LOOP=$[ ${DS_RUNONCE_LOOP} + 1 ]
    if [ ${DS_RUNONCE_LOOP} -ge ${DS_RUNONCE_EVERY} ]; then
      DS_RUNONCE_LOOP=0
      if [ -x ${HOME}/ds -a -z "$(screen -ls | grep '\.ds_r_o  ')" ]; then
        echo "------- ds watchdog is set to run once every ${DS_RUNONCE_EVERY} loops - starting ds in background screen..."
        ${HOME}/ds RUNONCE &
      fi
    fi
  fi
  echo '------- Memory watchdog: terminate_long_running.sh running...'
  # Terminate all relevant (servers, clients, pquery) too-long-running processes
  if [ -r "/test/terminate_long_running.sh" ]; then
    /test/terminate_long_running.sh
  elif [ -r "${HOME}/mariadb-qa/mariadb-build-qa/terminate_long_running.sh" ]; then
    ${HOME}/mariadb-qa/mariadb-build-qa/terminate_long_running.sh
  fi
  sleep 1
  echo '------- Memory watchdog: terminate_long_running.sh finished.'
  echo '------- Memory watchdog: main memory use evaluate/terminate running...'
  # Do not include pquery in the next filter statement; it is fine to terminate a memory-hogging pquery instance in principle (never actually observed)
  CMD="ps --sort -rss -eo pid,pmem,rss,vsz,comm | grep --binary-files=text -vE '${FILTER}|reducer'"
  eval "${CMD}" | head -n7
  HEADLINE=;PERCENT=;PID=
  HEADLINE="$(eval "${CMD}" | head -n2 | tail -n1)"
  PERCENT="$(echo ${HEADLINE} | awk '{print $2}' | sed 's|\.[0-9]\+||;s|[ \t]||g')"
  PID="$(echo ${HEADLINE} | awk '{print $1}' | sed 's|[ \t]||g')"
  if [ ${PERCENT} -ge ${KILL_PERCENT} ]; then
    echo "Process ${PID} is consuming too much memory (${PERCENT}%): terminating..."
    echo "Process ${PID} snapshot:"
    ps -ef | grep "${PID}" | grep -v grep
    sleep 1
    for((l=0;l<3;l++)){
      sudo kill -9 ${PID} 2>/dev/null
    }
  fi
  echo '------- Memory watchdog: main memory use evaluate/terminate finished.'
  echo '--- Sleeping for 13 seconds till next run.'
  sleep 13
done
