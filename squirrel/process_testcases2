#!/bin/bash
BASEDIR=/test/MD310522-mariadb-10.10.0-linux-x86_64-dbg

if [ ! -r ${BASEDIR}/bin/mysqld ]; then
  echo "BASEDIR (${BASEDIR}) does not contain bin/mysqld!"
  exit 1
fi
cd /home/$(whoami)/fuzzing
if [ "${PWD}" != "/home/$(whoami)/fuzzing" ]; then
  echo "Assert: PWD!=/home/$(whoami)/fuzzing"
  exit 1
fi

queue(){
  if [ -z "${1}" ]; then
    echo 'Assert: queue() received blank $1'
    exit 1
  elif [ "${1}" -lt 0 -o "${1}" -gt 3 ]; then
    echo "Assert: queue() received ${1} as the node ID."
    exit 1
  fi
  TODO[${1}]=$(awk "NR>=${NODE_START[${1}]} && NR<=${NODE_END[${1}]} {print \$0}" /tmp/afl_fulllist.txt)
  printf "%s\n" "${TODO[${1}]}" | xargs -I{} echo "cp '{}' /dev/shm/node${1}/in.sql; cd /dev/shm/node${i}; ./all_no_cl; ./test_pquery; sleep 2; if [ -r ./data/core ]; then echo '----------- /home/\$(whoami)/fuzzing/{}.string:'; ~/t | tee '/home/\$(whoami)/fuzzing/{}.string'; else echo '----------- /home/\$(whoami)/fuzzing/{}.NOCORE:'; touch '/home/\$(whoami)/fuzzing/{}.NOCORE'; fi; cd /home/\$(whoami)/fuzzing;\"" | tr '\n' '\0' | xargs -0 -I{} timeout --signal=9 5m bash -c \"{}\"
}

echo 'Commencing processing testcases...'
# Find all testcases
find . | grep 'sig:' | sed 's|^\./||' > /tmp/afl_fulllist.txt
# Filter already done ones
FILTER=$(cat /tmp/afl_fulllist.txt | grep -E '\.string|NOCORE' | sed 's|\.string||;s|\.NOCORE||')
printf "%s\n" "${FILTER}" | grep -v '^[ \t]*$' | xargs -I{} sed -i 's|{}.*||' /tmp/afl_fulllist.txt
FILTER=
TESTCASES=$(</tmp/afl_fulllist.txt)  # Re-read fullist after sed
printf "%s\n" "${TESTCASES}" | grep -v '^[ \t]*$' > /tmp/afl_fulllist.txt
TESTCASES=$(</tmp/afl_fulllist.txt)  # Re-read fullist after cleanup
COUNT=$(printf "%s\n" "${TESTCASES}" | wc -l)
if [ -z "${COUNT}" -o "${COUNT}" -eq 0 ]; then
  echo "No testcases to process... Done"
  exit 0
else
  echo "${COUNT} testcases to process, splitting..."
  if [ ${COUNT} -gt 40 ]; then
    echo "Will use 4 nodes to process the testcases..."
    NODES=4
    PERNODE=$[ ${COUNT} / 4 ]
    echo "Nodes 0 to 3 will process approximately ${PERNODE} testcases..."
    NODE_START[0]=1
    NODE_END[0]=${PERNODE}
    NODE_START[1]=$[ ${PERNODE} + 1 ]
    NODE_END[1]=$[ ${PERNODE} * 2 ]
    NODE_START[2]=$[ ${PERNODE} * 2 + 1 ]
    NODE_END[2]=$[ ${PERNODE} * 3 ]
    NODE_START[3]=$[ ${PERNODE} * 3 + 1 ]
    NODE_END[3]=${COUNT}  # Avoid off-by-1 issues as a result of the PERNODE division
  else 
    echo "Only ${COUNT} testcases are present; will use a single node to process the testcases..."
    echo "Node 0 will process ${COUNT} testcases..."
    NODES=1
    NODE_START[0]=1
    NODE_END[0]=${COUNT}
  fi
fi
if [ -z "${NODES}" ]; then
  echo "Assert: NODES is empty"
  exit 1
fi
  
# Prep verification nodes, and start processing queues
for ((NODE=0;NODE<${NODES};NODE++)){
  cp -r ${BASEDIR} /dev/shm/node${NODE}
  cd /dev/shm/node${NODE}
  rm -Rf FIREWORKS-BUGS COPYING CREDITS INSTALL-BINARY README-wsrep README.md THIRDPARTY docs man mysql-test 16* sql-bench support-files reducer* *gypsy *rr *valgrind sysbench* *multirun* repl* loop* insert* *stbe *.old gdb memory_use_trace multi* gal* clean_failing_queries *noprompt* fixin g binlog *.sql *.out sqlmode test_pquery m include
  ~/start >/dev/null 2>&1
  queue ${NODE}
}
