#!/usr/bin/sysbench
-- Copyright (C) 2006-2017 Alexey Kopytov <akopytov@gmail.com>

-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 2 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

-- ------------------------------------------------------------------------
-- OLTP Mix Queries of INSERT, UPDATE, DELETE, XA, ADD INDEX and DROP INDEX
-- Sample usage:
-- sysbench --mysql-user=root --mysql-socket="${PWD}/socket.sock" \
--          --tables=1 --table_size=10000 --mysql-db=test \
--          --mysql-ignore-errors=1061,1062,1091 --threads=16 \
--          --time=300 --inserts=20 --deletes=1 --updates=20 --xas=10 \
--          --add_index=1 --add_uniq_index=1 oltp_mix_queries_repl.lua run
-- ------------------------------------------------------------------------

require("oltp_common_repl")

sysbench.cmdline.commands.prepare = {
   function ()
      if (not sysbench.opt.auto_inc) then
         -- Create empty tables on prepare when --auto-inc is off, since IDs
         -- generated on prepare may collide later with values generated by
         -- sysbench.rand.unique()
         sysbench.opt.table_size=0
      end

      cmd_prepare()
   end,
   sysbench.cmdline.PARALLEL_COMMAND
}

function prepare_statements()
   -- We do not use prepared statements here, but oltp_common.sh expects this
   -- function to be defined
end

-------------------------------------------------------------------------------
-------------------------Common functions--------------------------------------
-------------------------------------------------------------------------------

-- Execute query under xa
function xa_wrap(thread_id, query_func, ...)
   local xid = thread_id
   local success, ret
   --local two_phase= (thread_id % 2)
   --local two_phase= math.random(0,1)

   --con:query(string.format("SET @@binlog_xa_two_phase=%u",two_phase));
   con:query(string.format("XA START 'xid_%u'", xid));
   success, ret = pcall(query_func, thread_id, ...)

   if not success then
     -- type(ret) is "table" only if --mysql-ignore-errors contains the error,
     -- that's why start sysbench with --mysql-ignore-errors=1213,1614,1205
     if type(ret) == "table" and
        ret.errcode == sysbench.error.RESTART_EVENT and
        -- deadlock or lock wait timeout or dup key error
        (ret.sql_errno == 1213 or ret.sql_errno == 1205 or ret.sql_errno == 1062)
     then
        local retx
        pcall(con.query, con, string.format("XA END 'xid_%u'", xid))
        con:query(string.format("XA ROLLBACK 'xid_%u'", xid))
     end
     error(ret)
   end

   con:query(string.format("XA END 'xid_%u'", xid))
   --con:query(string.format("XA COMMIT 'xid_%u' ONE PHASE", xid))
   con:query(string.format("XA PREPARE 'xid_%u'", xid))
   con:query(string.format("XA COMMIT 'xid_%u'", xid))

   --check_reconnect()
end

function xa_mix(thread_id, non_xa_func, ...)
   xa_wrap(thread_id, non_xa_func, ...)
end

function insert(table_name, k_val, c_val, pad_val)
   local k_val = sysbench.rand.default(1, sysbench.opt.table_size)
   local c_val = get_c_value()
   local pad_val = get_pad_value()
   if (sysbench.opt.auto_inc) then
      con:query(string.format("INSERT INTO %s (k, c, pad) VALUES " ..
                                 "(%d, '%s', '%s')",
                              table_name, k_val, c_val, pad_val))
   else
      if (sysbench.opt.auto_inc) then
         i = 0
      else
         -- Convert a uint32_t value to SQL INT
         i = sysbench.rand.unique() - 2147483648
      end

      con:query(string.format("INSERT INTO %s (id, k, c, pad) VALUES " ..
                                 "(%d, %d, '%s', '%s')",
                              table_name, i, k_val, c_val, pad_val))
   end
end

function delete(table_name)
   local rand_id = sysbench.rand.uniform(0, sysbench.opt.table_size*2)
   local query = string.format("DELETE FROM %s WHERE id = %d", table_name, rand_id) 
   con:query(query)
end

function update(table_name)
   local old_num = sysbench.rand.uniform(0, sysbench.opt.table_size*2)
   local new_num = sysbench.rand.uniform(0, sysbench.opt.table_size*2)
   local query =  string.format("UPDATE %s SET k = %d WHERE k = %d", table_name, new_num, old_num)
   con:query(query)
end

function add_index(table_name, col_name)
   local idx_name = "non_uniq_idx"
   local query = "SELECT COUNT(1) IndexIsThere FROM INFORMATION_SCHEMA.STATISTICS WHERE table_schema=DATABASE() AND table_name='sbtest1' AND index_name='non_uniq_idx'"
   local rs = con:query(query)
   local index_there = tonumber(unpack(rs:fetch_row(), 1, rs.nfields))
   if index_there == 1 then
      query =  string.format("ALTER TABLE %s DROP INDEX %s", table_name, idx_name)
      con:query(query)
   end
   query = string.format("ALTER TABLE %s ADD INDEX %s (%s)", table_name, idx_name, col_name)
   con:query(query)
end

function add_unique_index(table_name, col_name)
   local idx_name = "non_uniq_idx"
   local query = "SELECT COUNT(1) IndexIsThere FROM INFORMATION_SCHEMA.STATISTICS WHERE table_schema=DATABASE() AND table_name='sbtest1' AND index_name='non_uniq_idx'"
   local rs = con:query(query)
   local index_there = tonumber(unpack(rs:fetch_row(), 1, rs.nfields))
   if index_there == 1 then
      query =  string.format("ALTER TABLE %s DROP INDEX %s", table_name, idx_name)
      con:query(query)
   end
   query = string.format("ALTER TABLE %s ADD UNIQUE INDEX %s (%s)", table_name, idx_name, col_name)
   con:query(query)
end

function dml_mix(table_name, ins_pct, del_pct, upd_pct)
   local cur_pct = sysbench.rand.uniform(1, 100)
   if cur_pct <= ins_pct then
      insert(table_name, k_val, c_val, pad_val)
   elseif cur_pct <= (ins_pct + del_pct) then
      delete(table_name)
   elseif cur_pct <= (ins_pct + del_pct + upd_pct) then
      update(table_name)
   end
end

function rand_xa_query()
   local table_name = "sbtest" .. sysbench.rand.uniform(1, sysbench.opt.tables)
   local cur_rnd = sysbench.rand.uniform(1, 100)
   if (cur_rnd % 3) == 0 then
      insert(table_name, k_val, c_val, pad_val)
   elseif (cur_rnd % 2) == 0 then
      delete(table_name)
   else
      update(table_name)
   end 
end
function event(thread_id)
   local table_name = "sbtest" .. sysbench.rand.uniform(1, sysbench.opt.tables)
   local ins_pct = sysbench.opt.inserts
   local del_pct = sysbench.opt.deletes
   local upd_pct = sysbench.opt.updates
   local xa_pct = sysbench.opt.xas
   local add_idx_pct = sysbench.opt.add_index
   local add_unq_idx_pct = sysbench.opt.add_uniq_index
   local cur_pct = sysbench.rand.uniform(1, 100)

   dml_mix(table_name, ins_pct, del_pct, upd_pct)
   
   if cur_pct <= (ins_pct + del_pct + upd_pct + xa_pct) then
      xa_mix(thread_id, rand_xa_query)
   end

   if cur_pct <= (ins_pct + del_pct + upd_pct + xa_pct + add_idx_pct) then
      col_name = 'c'
      add_index(table_name, col_name)
   end

   if cur_pct <= (ins_pct + del_pct + upd_pct + xa_pct + add_idx_pct + add_unq_idx_pct) then
      col_name = 'k'
      add_unique_index(table_name, col_name)
   end
end
