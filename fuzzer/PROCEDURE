   # Fuzzing
1] ./start_fuzzing           # Starts 10 fuzzing nodes using mariadb-qa/fuzzer/afl_genstart_tmpfs_nodes

   # Core analysis
2] ./rocess_testcases_loop   # Starts process_testcases and restarts it if necessary. Consider it a watchdog
   ./process_testcases       # Automatically starts 1 or 4 core analysis nodes. Best to run at the same time as fuzzing nodes

   # Testcase reduction and analysis
3] ./reducers_run_loop       # Starts reducers_run and restarts it if necessary. Consider it a watchdog
   ./reducers_run            # Automatically runs reducers and ~/b reports for all testcases which do not have a report yet

   # Run statistics and cleanup
4] ./queue_stats             # Shows generic counter stats (number of testcases, core analysis count stats etc.)
5] ./list_unique_bugs        # First deletes known bugs, then produces a count and report of UniqueID's observed 
   ./del_known_bugs          # Deletes, based on UnqiueID's, all already known/logged bugs. Used by the list_unique_bugs script
6] ./reports                 # Outputs a list of all (completed and in progress) .report files together with their UniqueID
 
   # Runs termination
7] ./stop_all_fuzzing        # Stops all fuzzing (i.e. nodes started by start_fuzzing/afl_genstart_tmpfs_nodes)
8] ./stop_process_testcases  # Stops process_testcases and process_testcases_loop
9] ./stop_reducers_run       # Stops reducers_run and reducers_run_loop

   # Runs cleanup
*] ./clean_queues            # Use only when fuzzing is not running. Cleans up many AFL temporary files. Mainly for diskspace

   # Tools
*] ./find_uniqueid           # Search all .string files for a given UniqueID, for example as observed in ./report
*] ./check_loops             # Check if process_testcases_loop and reducers_run_loop are running

   # Other files
*] ./afl                     # A link to the script as linked into basedirs by ~/start. Linked here for quick editing purposes

   # File structures
testcase.string              # The UniqueID for the testcase. This file is generated for each testcase by process_testcases
testcase.NOCORE              # Generated by process_testcases for the testcase when it did not crash a given basedir
testcase.report              # A full, post-reducer, ~/b level report for the given testcase as produced by reducers_run

   # Other notes
*] Note that reducers_run/reducers_run_loop uses ~/b with direct /test basedirs; do not use either while this is running
*] However, you can read the note (search for [A] in reducers_run) on using ~/b whilst reducers_run is using reducer 
*] Note that if you use any _loop script, that no separate screen session will be started for the non _loop script
*] Note that ~/ds will regularly execute del_known_bugs if the script is present in /home/$(whoami)/fuzzing
*] Note that fuzzing, as well as process_testcases uses /dev/shm extensively. Use top to monitor and size tmpfs adequately
*] Note that at times, for an as yet unknown reason, it is necessary to ./start_fuzzing > ./stop_all_fuzzing > ./start_fuzzing
*] Fuzzing is resource intensive. Some additional reducers on a high end machine is fine, but pquery-run.sh is stretching it
*] The fuzzing scripts have been programmed to restart themselves inside a named screen session if not inside a screen already
*] Make sure to use ~/ds and ~/memory as usual

   # Most prominent TODO's
*] There may be a shortcoming in ./reducers_run_loop > ./reducers_run if no new screen session is started for the latter
*] Improve GUI output to avoid AFL bit-flip reporting but rather correctly output squirrel SQL verification stats
*] It would be handy to have a monitor/loop script for process_testcases also (watch for presence of process_testcases screen)
*] A ./status script (which includes ./check_loops bug also checks fuzzers running) woulpd be handy
*] Is there a performance impact due to the map resize?
*] Research SQL handling further; ref paper
