#!/bin/bash
set +H

# This script, by default, cleans up /data/NEWBUGS (or instead any directory passed as the first option to this script) by indexing all seen bugs into a newbugs.list (using 'find' as 'ls' will easily report 'ls: Argument list too long' for this directory as it often has 300-800k files in it). Then this list is reviewed line by line and for the first 3 occurences of any string, that bug/index is kept (iow the three string, sql and reducer files are kept). This thus eliminates >3 duplicates.

# User variables
ENABLE_OUTPUT=1    # 0 For silence, 1 For output
KNOWN_BUGS="/home/$(whoami)/mariadb-qa/known_bugs.strings"

# System variable(s) and options check
NEWBUG_COUNT="$(ps -ef | grep clean_newbug | grep -v grep | wc -l)"  # +1 occurence due to subshell
if [ "${NEWBUG_COUNT}" -gt 2 ]; then  # Ensure clean_newbugs is not running already!
  echo "Assert: ./clean_newbug is already running elsewhere!"
  exit 1
fi

TARGET=
if [ ! -r ${KNOWN_BUGS} ]; then echo "Assert: KNOWN_BUGS file ('${KNOWN_BUGS}' as set in this script) not readable!"; exit 1; fi
if [ ! -z "${1}" ]; then 
  if [ -d "${1}" ]; then
    TARGET="${1}"
  else
    echo "Assert: '${1}' was specified as an option to this script, however that directory does not exist, or the option specified existed but was not a directory."
    exit 1
  fi
else
  if [ -d "/data/NEWBUGS" ]; then
    TARGET="/data/NEWBUGS"
  else
    echo "Assert: no option was specified to this script, and /data/NEWBUGS does not exist: it is thus unknown which directory this script should cleanup."
    exit 1
  fi
fi
if [ -z "${TARGET}" ]; then echo "Assert: TARGET is empty."; exit 1; fi  # Dev assert

# Start main de-duplicaton and known bugs cleanup
if [ ${ENABLE_OUTPUT} -eq 1 ]; then
  echo "Commencing de-duplication and known bugs cleanup of ${TARGET}"
  echo ".. Changing to target directory ${TARGET}"
fi
cd ${TARGET}
if [ ${ENABLE_OUTPUT} -eq 1 ]; then
  echo ".. Compiling sorted newbugs.list of strings (takes ~2-3 minutes on high end server with ~250k .string files)"
fi
find -maxdepth 1 -type f -name '*.string' | sort -nr > newbugs.list
if [ ! -r ./newbugs.list ]; then echo "Assert: './list' does not exist after creating the same"; exit 1; fi

COUNT=$(wc -l ./newbugs.list 2>/dev/null | sed 's| .*||')
if [ -z "${COUNT}" -o "${COUNT}" -le 0 ]; then 
  if [ ${ENABLE_OUTPUT} -eq 1 ]; then
    echo "Nothing to do!"
    exit 0
  fi
fi
if [ ${ENABLE_OUTPUT} -eq 1 ]; then
  echo ".. Found ${COUNT} string files"
fi

delete_newbug(){
  # String file
  if [[ "${STRING_FILE}" == "./newbug_"* ]]; then
    if [[ "${STRING_FILE}" == *".string" ]]; then
      rm ${STRING_FILE} 
    fi
  fi
  # SQL file
  DELETE="$(echo "${STRING_FILE}" | sed 's|\.string|.sql|')"
  if [[ "${DELETE}" == "./newbug_"* ]]; then
    if [[ "${DELETE}" == *".sql" ]]; then
      rm ${DELETE}
    fi
  fi
  # varmod file
  DELETE="$(echo "${STRING_FILE}" | sed 's|\.string|.varmod|')"
  if [[ "${DELETE}" == "./newbug_"* ]]; then
    if [[ "${DELETE}" == *".varmod" ]]; then
      if [ -r ${DELETE} ]; then  # TODO: Remove this check later (mid 2021), as some older NEWBUGS dirs do not have varmod files yet
        rm ${DELETE}
      fi
    fi
  fi
  # Reducer file
  DELETE="$(echo "${STRING_FILE}" | sed 's|\.string|.reducer.sh|')"
  if [[ "${DELETE}" == "./newbug_"* ]]; then
    if [[ "${DELETE}" == *".reducer.sh" ]]; then
      if [ -r ${DELETE} ]; then  # TODO: Remove this check later (mid 2021), as some older NEWBUGS dirs do not have reducer files yet
        rm ${DELETE}
      fi
    fi
  fi
} 

if [ ${ENABLE_OUTPUT} -eq 1 ]; then
  echo ".. De-duplicating (3 occurences max), and removing known bugs"
fi
IDX=0
rm -f newbugs.dedup
touch newbugs.dedup
while IFS=$'\n' read STRING_FILE; do
  IDX=$[ ${IDX} + 1 ] 
  STRING="$(cat ${STRING_FILE})"
  # Look if the issue is known already
  FINDBUG="$(grep -Fi --binary-files=text "${STRING}" ${KNOWN_BUGS})"
  if [ "$(echo "${FINDBUG}" | sed 's|[ \t]*\(.\).*|\1|')" == "#" ]; then FINDBUG=""; fi  # Bugs marked as fixed need to be excluded. This cannot be done by using "^${TEXT}" as the grep is not regex aware (-F used), nor can it be made to be, due to the many special (regex-like) characters in the unique bug strings.
  if [ ! -z "${FINDBUG}" ]; then  # Bug is known already
    if [ ${ENABLE_OUTPUT} -eq 1 ]; then
      echo ".... [${IDX}/${COUNT}] ${STRING_FILE}: already known issue: filtering"
    fi
    delete_newbug
  else
    # Count nr of occurences in ./newbugs.dedup, a file used to count/add up to 3x the same bug: the rest is discarded
    DUPS="$(grep -Fic --binary-files=text "${STRING}" ./newbugs.dedup)"
    if [ -z "${DUPS}" -o "${DUPS}" -eq 0 -o "${DUPS}" -eq 1 -o "${DUPS}" -eq 2 ]; then  # Keep 3 occurences
    #if [ -z "${DUPS}" -o "${DUPS}" -eq 0 ]; then  # Keep only 1 occurence
      if [ ${ENABLE_OUTPUT} -eq 1 ]; then
        echo "... [${IDX}/${COUNT}] ${STRING_FILE}: new issue, occurence $[ ${DUPS} + 1 ]/3, adding to ./newbugs.dedup"
      fi
      echo "${STRING}" >> ./newbugs.dedup
    elif [ "${DUPS}" -ge 3 ]; then  # Keep 3 occurences # It should never be greater then 3: defensive coding
# Code temporarily disabled (1/4/21 as more then 120k testcases present)
#      # Check first if this is not a really small testcase (less than or equal to 5 lines)
#      SQL_FILE="$(echo "${STRING_FILE}" | sed 's|\.string|.sql|')"
#      SQL_LINES="$(wc -l ${SQL_FILE} | sed 's| .*||')"
#      SQL_FILE=
#      if [ "${SQL_LINES}" -le 5 ]; then 
#        if [ ${ENABLE_OUTPUT} -eq 1 ]; then
#          echo "... [${IDX}/${COUNT}] ${STRING_FILE}: new issue, occurence 4+, though not filtering as testcase is only ${SQL_LINES} lines"
#        fi
#      else
      if [ ${ENABLE_OUTPUT} -eq 1 ]; then
        echo "... [${IDX}/${COUNT}] ${STRING_FILE}: new issue, occurence 4+: filtering"
      fi
      delete_newbug
#      fi
      SQL_LINES=
    fi 
  fi 
done < ./newbugs.list

# Other data cleanup
rm 16*_* 2>/dev/null # {epoch}_run, {epoch}_start etc. scripts created by reducer (can easily be recreated if needed)

# Fireworks cleanup
if [ -d /data/FIREWORKS ]; then 
  grep --binary-files=text -vE '^[ \t]*$|^#' ${KNOWN_BUGS} 2>/dev/null | sed 's|[ \t]\+##.*$||' | xargs -I{} grep --binary-files=text -Fi "{}" /data/FIREWORKS/*.string 2>/dev/null | sed 's|.string:.*$|.*|' | xargs -I{} echo "rm {}" | xargs -I{} bash -c "{}"
  if [ ${ENABLE_OUTPUT} -eq 1 ]; then
    echo '.. Fireworks cleaned'
  fi
fi

# Cleanup
rm newbugs.dedup newbugs.list
